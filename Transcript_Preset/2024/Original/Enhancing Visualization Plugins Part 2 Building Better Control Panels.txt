 people saying hello. All right, cool. So I think this one's a little bit funny. We've got a small crowd because I think something went wrong with our integration where people filled out the web form and got automatically enrolled in zoom. So we're just going to plow through this today and record this. But if anybody from the future is wondering why that didn't work and they're watching the recording instead of the live broadcast. And re-run this event if we need to and take your questions at some other date. So sorry for the misfire there. But in any case, let's go ahead and dive in. I will share my screen. And hopefully you see this lovely slide deck. So here today we're talking about enhancing your visualization plugins by building better control panels. We're going to talk about all sorts of different techniques and best practices. And first I'd like to go ahead and make quick introductions. I'm Evan Erzakis. I'm a super set PMC member and I work as a developer advocate for preset. And then I don't know if you'd like to introduce yourself. Yeah, so yes, my name is Vila Brouffat. I'm also PMC a number of Apache super set that work for Apple building various visualization visualization services. Alright, so yeah, Vila is going to be calling me out on all the things I'm getting incorrect or missing as I go through this. There's a lot to cover. So I'll do my best. But this is part of a series. If you didn't see the prior ones will give you information on that. So get your screen capture ready. The other ways you can interact with us here are of course in the zoom chat. But if you have questions, typically I say ask them in the Q and A tab because that's more manageable for us. Or you can ask questions later on super set slack. There's the link if you're not enrolled already or you can just send me an email failing all other options. And here are those links for the prior edition of this, which was kind of an overview and of all the different topics we're going to get into for enhancing your visualization plugins. And also goes into the topic of chart metadata and you know how that works and the vispickery gallery and all of that kind of stuff. So you can see the blog or you can see the video or both. The blog for today's content, by the way, is coming soon. The blog post is almost ready, but it's a it's a lengthy one since there's a lot to dive into so we needed a little more time. Okay, so today's topics control panels control panels 101, I guess you could call it will start there. And let's begin with talking about what controls even are and why you should care. We'll talk about building better control panel layouts, including getting dynamic with how these things are displayed. And then getting into some of the cool techniques to make it more user friendly to switch between these visualizations as well. And there's a lot of little stuff along the way here. Now standard disclaimers when we're talking about plugins, you can use basically anything JavaScript to build these visualization plugins. So these things are not all created equal. They have different interfaces and support different features. So it gets a little crazy. And not all of this architecture we're going to show you is ideal. So we're going to give you a little warning at the end about what might be refactored in the future. I try to answer all your questions, but people usually have a lot of interesting edge cases when it comes to these plugins and we probably can't answer everything, but we'll do our best. Okay, so table stakes, what is a control panel. It's basically this section of explore. I'm sure you've all seen it. But we've got our controls laid out in two tabs data and customize where data are typically with certain exceptions, things that affect your query and customize are things that typically don't require adjusting your query, but will affect the visualization layout in one way or another. Then we've got the viz picker itself with the sort of your top plugins that you can switch between here. And you got the view on charts link to pop up in the viz picker gallery. And then of course you've got these sections of controls like the query section and the filters section and well, so forth and so on. And you've probably seen that. So I'll blast right on into the general anatomy of a plugin. You're here as developers. So you've probably used the Yomang generator or kind of ripped apart one of the pre existing superset plugins to start digging into the code. And this is more or less the layout of the files structure of a given plugin. The part we're going to be talking about today, of course, is control panel dot T. S. And the important thing I just wanted to reiterate here is that those controls are a bunch of react components acting as inputs for, you know, columns and various other things. And what they affect to other parts of your plugin, namely build a query, which can take these control values and affect your query that you send to the superset API and to get different results, like say a time ranger, something like that. What they can do is you can use these control values as part of the form data, as we call it to transform props. So those might be things that reflect reflect a controls value as a certain prop that you would use in your react component that is your actual, you know, visualization. So say like the inner radius of a donut chart as an example that's one you'll probably see in some of these slides. It's a nice simple example. So what is the control itself in terms of code. It's a bunch of different stuff, but here is kind of a relatively simple one and the important parts of highlighted here are the type, which is in this case, a slider control. That's a funny way of referring to an underlying react component. So there is actually in supersets code base, a slider control react component that's referred to as a string here. You give it a label that displays here as seen, and you can give it a description. There's a lot of other properties that go into this, but these are kind of the essential ones, I would say. So we'll get into some of more advanced fields as we go through how these things are treated in layouts and making things more dynamic. And I wanted to bring attention to shared controls. In any software, you really don't want to repeat yourself and you don't want to reinvent any wheels if you don't have to. So superset and all of its plugins use a whole bunch of these shared controls that are pre existing. And there's a laundry list of them. I would encourage you to go and dig through the code if you're interested in exploring these, but here I've kind of curated a little bit of a selection of some of the greatest hits. So in pretty much any, any plugin, you're going to be utilizing columns and metrics and playing with, you know, group buys and all of this stuff that will affect your query so you can get the data back from the API, the way you want it to shape your plugin, your plugins data, provide the right shape of data to your plugin. So this is where they all live. You can import them this way. Here's the actual file. If you want to go looking through the entire kind of selection of these. But yeah, these are the ones that tend to be used by most plugins. So start there. And then, as I mentioned, all of those are built upon some form of react component. Most of our components are using, you know, ant design under the hood for various things like sliders and check boxes and stuff like that. But if you want to build a new control that doesn't exist in those shared controls, I was mentioning this file right here contains all of those react components that things are built upon. So if you need a certain typo slider control, you'd probably want to build it based on this slider react component just pass along the right props. So let's get into the layout. Yeah, how do you how do you fit these things together to build an actual control panel. So every plugin has a control panel file and that control panel file has a control panel config, which consists of three sections. The first one is the most important one that we're really going to dig into a bit. It's the control panel sections. And this is the actual layout of these controls and rows and columns. There's another section is control overrides. This is to kind of take a control and apply different props on top of it and kind of overwrite what it's doing. We'll probably refactor that out at some point in the future. So I would just stay away from that. And then form data overrides is a way where you can provide additional overrides to the JSON object that gets passed through as form data. To the other parts of your plugin. So you can do things like customize the query or things like that. This is something you typically don't want to use, but we use it in one special case, which is visualization switching. So we'll cover that as well and a little bit. Okay, so the layout these control panel sections I was alluding to are there an array of arrays. And these are the sections you can see sorry for the kind of weird lines here, but the important part is any section has a title. Any section is collapsible and you can set the default state of that. So something like advanced analytics, for example, is usually collapsed by default because you probably don't need it. But then there's this control set rose business and that's where these controls actually go. So each of these arrays is a single or multiple control. And oops, did I not have that slide? Hold on a second. Oh, yeah. Here's one that shows possibly a couple of different controls being in one row than color scheme here is in the subsequent row. And you can refer to these pre existing controls from that shared controls file by string like so. You see this most of the time in the code base. It's not a typical JavaScripty pattern normally you would include something like a react component here. So I think at some point we're going to go through and refactor a bunch of that stuff to support react components directly instead of this funny string reference. You can do that yourself. You can also import a control and refer to it by actually, you know, JavaScript reference or you can import things and use the HTML tag or react the react component directly in here. So it used to be that you would see funny HTML tags in these things to you see little HR tags and stuff like that. But most of that's been cleaned up in favor of proper react components and shared controls. And this is something I saw in the code. I'm pretty sure this is just a spacer when people stick a nolan like that, but I want some very verification. I could actually set something here. So previously the convention was to usually have two controls on one row. So there would be kind of two columns, especially in the customized section that used to be very, very common before. We've kind of moved away from that. So nowadays the best convention is to only have a single control per row. And that's what we recommend going forward. Yeah, and I think at some point one day in the distant future, we might even reconsider this kind of array of arrays layout method and go with something that's more kind of react component based, but that's that would need proposals and consensus and all that fun stuff. Okay, so then you're a lot of people wonder at this point, what's the deal with those two tabs. How do I get my sections of controls into one tab or the other, what's the rhyme or reason here. And this thing's a little unusual, but it's all based on this idea of instant controls. So in superset your controls can instantly trigger the re rendering of a chart, like if it doesn't need to affect the underlying query, you can set it to just redraw things immediately. Or you can have it so that when you change the value, you'd have to click this update chart button at the bottom of the control panel. And that will actually send a query to the back end and get revised data and then redraw the chart. So some things work instantly, some things don't. And you would use this render trigger property to set that. Now, as far as the layout of those two tabs, the way it works right now is that if every control in a section uses the render trigger as true, then it will automatically put that in the customer. And then it will customize tab. If it has one or more controls that require looking that update chart button render trigger as false, then it'll put it in the data section. And of course, that doesn't work for everybody, because there are exceptions where you want to trigger a query from the customized section or not trigger a query from the data section. So what can you do there. And then you can have override property, which allows you to basically force it to customize or force it to data. It's a little unusual, but you can do that. Okay, so hopefully now that kind of makes sense about how you put controls in the right place where you get these controls, how you build them, what all the moving parts are. And then you can have a little fancy with them. And one of the things I want to talk about is dynamic controls where you don't want to build a UI for your users that's just like a giant wall of knobs and buttons. Nobody wants to kind of figure out how to use your plug in if it has all the controls visible all the time. So you want to do, you know, you know, you best practices of sort of progressive reveal of these controls and update them or reveal them as they become relevant. So one example of that that I always point at, so sorry if you've seen this one, is just this simple little inner radius slider on the pie chart. When you click the donut check box suddenly this inner radius control is revealed. And it's just a nice understandable case because if you if you're not making a donut chart, if it's just a standard pie chart, you don't need that control. So get it the heck out of the way. That was just a single control that illustrates the point. Perhaps a more complicated one would be the access controls on the bar chart where you can use this radio button, which doesn't really look like a radio button, but it is to switch between horizontal and vertical, you know bars and columns. And when you do that, everything is rejiggered. The X becomes the Y, the Y becomes the X and all of the form matters and other things that come along with those access formatting are switched around based on the value of that control. So other use cases might be like the table chart where you have different controls for the different modes that a chart can be in aggregate versus raw records in that case, or if you just have even entire sections of controls that become relevant or not depending on selection. Then of course check box like that inner radius one is a good choice of component to build dynamic controls around, or you can do this with select menus too. So, you know, if you selected a different mode of a chart and just hypothetically area line or stream, then you would get the different, you could reveal or hide the subsequent, you know, more granular options around that. And this map state to props business is something, be like and probably explain better than me, but this is one of the ways where you can actually pull things out of reacts state and use those values from other controls to populate this particular control and set its value. But there are some risks that go along with this that maybe if you look and explain a little better. I think for the most part, this is usually used to populate values and drop down, drop down menus and things like that. So when the control panel is being initialized, it pulls in values from this state object that contains information about what the underlying data sources is, what kind of columns there are. So, I think one good example is the metrics control, what the metrics control is being populated, it looks at what metrics are available in the data set and then uses those to render the drop down to the metrics. One thing that might come to mind here is you might want to change the values based on what values you have in other controls and that tends to be problematic because that can cause these kind of race conditions where changes to one control then leads to changes in another control and that kind of cascades out of control. So there's other properties for that. So what we kind of usually see is we use map state to props to just render the initial values for the drop down from from the state. And then if you want to initialize controls based on other control values, you use this initial value prop and then there's one more that's called re render. So that's slightly more complicated one, but it's being used in a few plugins. So if you look at the code base, you can look at how the re render and initial value props are being used there. And I think that's kind of fairly self explanatory as to how these work in practice. Cool. Then yeah, there's actually there's a lot of other props that can go into these controls that I didn't go totally deep on. In fact, I think I might have started making but didn't finish making a slide about this validators, for example. So if you want to make sure that your control sends certain types of values to the backend and not others, there are some built in validators you can use like non empty obviously here, but there's also to make sure that it's you can validate that something's an integer or a number. There's a handful of other validators you can leverage. So again, there's there's an awful lot of controls being used throughout the supers at code base. It's best to kind of take some of your favorite visualizations that are doing something akin to what you're looking to do and sort of start to unwire them and look look at them as examples. And I would say that the some of the newest visualizations are a little richer, especially like the charts ones, for example, those are good examples to dig into. Alright, and another best practice as far as user experience besides hiding and showing relevant things is making it easy for your users to switch between visualizations because this is after all the data exploration tool and you're probably most likely digging around in your data trying to find the right visualization to tell the data story you want to tell what is you know going to show some insight in a better way than some other visualization. And we do this by normalizing a denormalizing form data and what that means in the terms I usually use is safe or smooth is switching so safe. Vis switching means that when you switch from one visualization to another, it doesn't throw away your data. So if you use that inner radius of the donut chart as an example, if you switch from a donut chart to a table, you no longer need that inner radius control and we used to throw that away. So when you switched back to the donut chart, you would have to set that value again. But right now that's retained so that's safe is switching smooth is switching is something a little more like what you see here where certain controls involving metrics or metric or any sort of group buys and things like that are normalized and that means they're kind of put into kind of simplified categories. And when you switch to another visualization, they're denormalized, meaning that visualization can kind of take the parts out of that data that it needs to populate its own controls. So your values move around from one to the other and you don't have to kind of start over by populating these inputs when you switch visualizations. Now the way that works is interesting. I won't go too much into the normalizing, but basically the code base takes care of that for you as a plug and developer, you shouldn't have to worry about it because all of the controls that we typically use are marked like all of these things are metrics, all of these things are columns and that normalization happens automatically. So the part you'll probably need to be more aware of as a plug and developers, the denormalization. And that's where these you can look through a bunch of examples in the code base to see this being done all over the place, but that's where that form data overrides part of your chart config comes into play. So you take all of the form data from your plugin and then you're actually going to take some of your more granular inputs that might be a single metric under a different name. And basically pull the specific metrics you want out of the normalized metrics array, if that makes sense. And I've ever tried to explain this, but in this case, we've got a control called entity and it's looking for a single column. So if there's a bunch of columns that are in the normalized form data from the your prior plug in the switching away from this will actually shift off the first column and populate the entity control with that singular column. And the metric one is doing the same thing here where you might be moving from something like a table visualization that has a whole slew of metrics. But when you come over to this, we make the assumption that the first metric is probably the most important one. And we take that metric off and populate the singular metric control with it. If that's not the metric you wanted, you know, we have to make a guess you can remove it, you can swap it, no big deal. And so those are the shift ones that take a singular metric or column out of the data. And you can also pop all columns or pop all metrics. Those are the other methods if you just want to grab everything. So you can get much fancier in here and use all kinds of filters and things to try to look through the column data and grab the exact one you want if it's available or, you know, from there on it's code and it's up to you. That's how you can more smoothly switch between visualizations. And then when you switch to the next one again, all that normalization of these controls happens automatically so the next plugin can pick it up into the same sort of operations. Okay. So upcoming changes. And as a developer, you need to be aware of where this world of plugins is going. And these are some things that we're aware of that might happen to control panels in the near future. There are some deprecations coming. And a lot of this is as part of 4.0. Every time we do a major version of superset. We try to simplify the code and get rid of some old legacy things that are not being used anymore. We have drag and drop controls. It's been set to true by default for quite some time. But there is a really old UI around these controls where you could click a little plus button. And if you haven't seen it, don't worry about it. But it's going to be gone. So some old plugins may have a little difficulty there. There's also this generic chart axes thing where superset was built mainly to display temporal charts. And over time, of course, people want their x axis or y axis on any given chart to be categorical or numeric for all sorts of reasons. So superset now supports that. But there's a lot of complexity around that. Which I don't know if you live and was to elaborate on that at all, you're the expert here. But we're going to be trimming quite a bit of that away. I think people need to worry about as far as developer risk there, you think. No, I think just kind of staying on top of what's being deprecated. So I think these are these are probably listed somewhere in the release notes or the forthcoming release notes. So as these frameworks kind of develop and mature will be removing some of these controls. So there's. There are certain dedicated control names that are being used by by these kind of legacy charts. There's something called time see time grain SQL a time grain. And those granularity. So those are kind of on their way out right now. And you should be kind of steering away from those. I think in general, you should when you're developing a new plugin, you should be thinking about how you could be supporting other than than time series x. I think that's something that's kind of good to keep in mind. So superset supports it fairly well nowadays. And I think if. If you make your plugin as generic as possible, meaning that you know, you can use categorical or or numerical or temporal axis, I think that just makes your your plugin richer and makes it for versatile for friendly users. But I think these are going to be all listed in the release notes and when we when we do deprecate. We do follow semantic versioning. So when something is removed, it's going to be fairly clearly stated in the previous release that this is being deprecated and then this is going to be really removed in the next major version. So just talking about those major releases, we are working on four dot O right now and then any of the proposals that haven't reached official consensus will be going into five dot O handful of months later. And then you can actually be part of that consensus process. Things that may go away someday, I was noticing a lot of them as I was actually building these slides that there are shared controls that are no longer being used. There are, I'm sure some of those react components pointed out that are probably not being used. There's. So we might clean some of that stuff up at any given point and we might go toward being more react component based than using this array of arrays of strings kind of layout method that's a bit legacy. And there are other legacy things too like if you're using validators, you'll see that there are, you know, numeric validators and legacy numeric validators. So stay away from anything that says legacy because that's an obvious place to do some cutting in the future. All right. And then, yeah, possible reflectors, I guess I'm already kind of covered this. But chart overrides is probably something we should get away from at some point. So I wouldn't lean on that too heavily. And this tab override logic that I was explaining where things that are instant or when all the controls are instant, they get put in the customized tab and otherwise they go into charts like we might get more declarative about that in the future instead of having everything be an override. And we also have those those components that kind of power these controls, I guess you could say are in the superset code base where the control definitions are in one of the monorepo packages called superset UI. So some of that stuff might move around. We're going to try to do that in a non breaking way if we ever get to it. So just to heads up. All right. And then what's next? It's kind of up to everybody here. And I know maybe not everybody's here in person today, but we'll be watching this on YouTube or whatever. So I would love to hear from you on Slack or by email. We'll give you those coordinates again, but there's a lot more we can get into with these visualizations and adding features to them. There's things we will be talking about like cross filtering and drilling and legends and building better tests, adding react storybook entries, conditional formatting, currency formatting, and definitely, you know, all this chart access control stuff. So there's a heck of a lot we're going to get into in this ongoing series. But if anybody has any priorities they'd like to bring up, you know, your input matters. So let us know. And then with that, we'll get into questions. And I think our audience is a bit fragmented today due to that little hiccup with the invitations. But if anybody has anything they'd like to ask, please feel free to drop it in the Q&A channel. Or if you live, there's anything else you'd like to bring up that I forgot by all means go for it. I think one thing that I just want to bring up is the fact that this is a community effort. So I think the core team that's been developing these plug-in frameworks and plug-ins has been fairly small. But that doesn't mean that it has to remain small. So I think especially if you have experienced building front end applications, you know, react, you may be playing around with the superset plug-in system. We would be very happy to have you on, you know, jump in and help us clean up some of this stuff. And especially with, you know, getting in some new fresh eyes, I think that would be very helpful for identifying the kind of legacy components and where we could improve. So if anyone does want to participate in this, we'd be very happy to onboard you. Yeah, and there's speaking of onboarding plug-in developers. There's a whole other thing I forgot to mention that I wanted to do in the intro. We're going through this blog series of kind of covering different features you can bolt on to your plugins. But the other thing that this spurred was a blog post I wrote. Let me see if I can find it real quick. And it's this one where I got very curious to go looking around on NPM and find some of the plugins that are out there in the universe that are basically not advertised at all. And there's there's a lot of them different cool maps and alternate to bar charts and sinky charts and tables and all sorts of stuff. People are developing cool things and these exist in the world in various states of quality. I admit, but what I wanted to bring attention to is that there's this new superset plugins directory on our superset wiki. So if you have built a plugin and you'd like to get some eyes on it and kind of evangelize it a little bit, you can get it on this wiki page. I'd love to see more of this and start taking baby steps toward kind of a plugin ecosystem or marketplace or whatever you want to call it. And to do that, there's a handy little form here that you can just kind of drop the name of your NPM module or URL or whatever. And you know, one of us committers will come along and add that to the wiki. So please, if you're building stuff, share it. So the world can use it. We do have a question. Are there any plans on changing how the chart itself can communicate with the control? There are some use cases where it's easier to change a configuration in the chart itself and have it be reflected than control panel. Yeah, there's a lot of use cases for that. For example, one that has come up before is like say you've rendered a table chart. And on one of the columns, you want to be able to select a format for that column or select that it's centered instead of left align something like that. That right now it's not the case where the chart when changed will send data through like a Redux lifecycle or something to change the controls. Right now you have to set alignment of each column in the control panel that connects to the chart. But the chart doesn't complete the feedback loop and adjust the control panel. So there are some people that somehow accomplished that on forks, but nobody's contributed that yet. I hope that someone does. But yeah, there's there's use cases, but I don't think anybody has a sip open for this, which is an improvement proposal. I think we'd be very open to that. I don't know if you've heard of anybody making progress there. But I think there's been various levels of discussion around this. I think one thing that we would need is is a loop where it would be possible when you're interacting with the chart to trigger saving, you know, saving the form data back to the backend. And I think that's that's what's required to persist these changes. So various charts have up, you know, the, for instance, the table chart where you can resize the columns or, you know, manipulate what you're seeing that's possible. But then, you know, when you refresh your browser, it's all wiped out. So I think there's been discussion for over a few years already about moving away from having a separate dashboard app and the explorer app and actually kind of combining those. So that the logic for manipulating the charts would also be available in the dashboards and that would make it possible to edit charts in place within the dashboard view. And if we had this kind of a mechanism then, you know, persisting changes from from the charts interaction down to the chart metadata would be completely possible. But right now, due to architectural limitations, that's not possible. Yeah, but this is definitely something that's kind of up for grabs there. So if anyone wants to work on this, you know, we should just get the sit-out, have a discussion about how this is being implemented in practice and what kind of a roadmap there would be. And then we could definitely get started on this because because I think this would be a great feature for, you know, being able to edit charts in place within the dashboard view. Yeah, there's a follow-up comment that there is a hook called set control value that exists, but seems a little problematic in terms of calling it repeatedly and quickly. Yeah, I don't, I don't know, haven't dug into that. So, you know, if you find kind of a root cause of what the issues there might be, hopefully it's something we can improve. But riffing on what Vila was talking about the ability to kind of edit charts very quickly from the dashboard context is something that yeah, every but a lot of people want to see that in various ways. So there are design discussions that happen around that. And I think with this use case, what we'd want to see is just keeping it simple in terms of permissions and things like that. So if you want to edit a table column alignment in a dashboard context, you should be probably editing that chart with editor writes like just to see what the results are. So there's a lot of different types of writes like just the way they're set up today and not some new thing where you can kind of override form data for like a personal context like I might want to see something left aligned but not update it for everybody else. So there's. But what is the context here am I trying to make the edit for everybody or am I trying to make the edit for my own data consumption where it's more of a personal. This is how I want to see it for the moment thing. So it gets tricky in the dashboard context. But it's definitely going to be a cool thing when we solve these problems. So. Actually, a related thing that's or a discussion, I think it's been planned for super set five. Oh, which is user preferences. So right now, everything is kind of global and. There's certain format things that you have to define and deployment can take, which means that every single user who's using this will be seen the same way. But to be able to, for instance, customize time zones, customize, you know, number formats per user. That's not possible right now, but it's something that's being discussed and I think that's also something we need to take into consideration when considering you know these in place chart edits within the dashboard context. Another one that came up or comes up fairly often is accessibility, which is interesting when it comes to visualizations because things like each arts allow you to do. What do they call it decals, I think is the term where you can overlay a pattern on something like a bar and a bar chart. So those that have low color acuity or color blindness can see patterns instead of colors. And that's something where you might want to turn that on for yourself. So all of your dashboards show up with these sort of accessibility features. But maybe you don't want to turn that on for. So everybody looking at every chart in your workplace sees all these little dots and pluses and things on their bar charts. But yeah, anyway, much more to dig into. I think we're effectively at time and so we'll wrap this up. And if anybody has questions again, please reach out on Slack or by email or however you can get to us join our operational group meetings for about, you know, improving quality or releasing and all of that stuff. It's all on the SuperSet community calendar, which is available on the SuperSet website. So thank you, Vila, for all the context. Thank you for joining and helping me through all this and thank you everybody for joining. We'll see you next time. Thank you. Bye bye.